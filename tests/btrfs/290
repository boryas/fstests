#! /bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (C) 2021 Facebook, Inc. All Rights Reserved.
#
# FS QA Test 290
#
# Test btrfs support for fsverity.
# This test extends the generic fsverity testing by corrupting inline extents,
# preallocated extents, holes, and the Merkle descriptor in a btrfs-aware way.
#
seq=`basename $0`
seqres=$RESULT_DIR/$seq
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
status=1	# failure is the default!
trap "cleanup; exit \$status" 0 1 2 3 15

# get standard environment, filters and checks
. ./common/rc
. ./common/filter
. ./common/verity

# remove previous $seqres.full before test
rm -f $seqres.full

_supported_fs btrfs
_require_scratch
_require_scratch_verity

cleanup()
{
	cd /
	rm -f $tmp.*
}

get_ino() {
	file=$1
	ls -i $file | awk '{print $1}'
}

validate() {
	f=$1
	sz=$2
	# buffered io
	cat $f > /dev/null
	# direct io
	dd if=$f iflag=direct of=/dev/null status=none
}

# corrupt the data portion of an inline extent
corrupt_inline() {
	f=$SCRATCH_MNT/inl
	head -c 42 /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# inline data starts at disk_bytenr
	# overwrite the first u64 with random bogus junk
	$BTRFS_CORRUPT_BLOCK_PROG -i $ino -x 0 -f disk_bytenr $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# preallocate a file, then corrupt it by changing it to a regular file
corrupt_prealloc_to_reg() {
	f=$SCRATCH_MNT/prealloc
	fallocate -l 4k $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# set extent type from prealloc (2) to reg (1)
	$BTRFS_CORRUPT_BLOCK_PROG -i $ino -x 0 -f type -v 1 $SCRATCH_DEV 2>/dev/null >/dev/null
	_scratch_mount
	validate $f
}

# corrupt a regular file by changing the type to preallocated
corrupt_reg_to_prealloc() {
	f=$SCRATCH_MNT/reg
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# set type from reg (1) to prealloc (2)
	$BTRFS_CORRUPT_BLOCK_PROG -i $ino -x 0 -f type -v 2 $SCRATCH_DEV 2>/dev/null >/dev/null
	_scratch_mount
	validate $f
}

# corrupt a file by punching a hole
corrupt_punch_hole() {
	f=$SCRATCH_MNT/punch
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	# make a new extent in the middle
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	head -c 4k /dev/zero | tr '\0' Y | dd of=$f bs=4k count=1 seek=1 conv=notrunc 2>/dev/null
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# change disk_bytenr to 0, representing a hole
	$BTRFS_CORRUPT_BLOCK_PROG -i $ino -x 4096 -f disk_bytenr -v 0 $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# plug hole
corrupt_plug_hole() {
	f=$SCRATCH_MNT/plug
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	fallocate -p -o 4k -l 4k $f
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# change disk_bytenr to some value, plugging the hole
	$BTRFS_CORRUPT_BLOCK_PROG -i $ino -x 4096 -f disk_bytenr -v 13639680 $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# corrupt the fsverity descriptor item indiscriminately (causes EINVAL)
corrupt_verity_descriptor() {
	f=$SCRATCH_MNT/desc
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# key for the descriptor item is <inode, BTRFS_VERITY_DESC_ITEM_KEY, 1>,
	# 88 is X. So we write 5 Xs to the start of the descriptor
	$BTRFS_CORRUPT_BLOCK_PROG -r 5 -I $ino,36,1 -v 88 -o 0 -b 5 $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# specifically target the root hash in the descriptor (causes EIO)
corrupt_root_hash() {
	f=$SCRATCH_MNT/roothash
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	$BTRFS_CORRUPT_BLOCK_PROG -r 5 -I $ino,36,1 -v 88 -o 16 -b 1 $SCRATCH_DEV >> $seqres.full
	#$BTRFS_CORRUPT_BLOCK_PROG -r 5 -I $ino,36,0 -v 88 -o 120 -b 5 $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# corrupt the Merkle tree data itself
corrupt_merkle_tree() {
	f=$SCRATCH_MNT/merkle
	head -c 12k /dev/zero | tr '\0' X > $f
	ino=$(get_ino $f)
	_fsv_enable $f
	$XFS_IO_PROG -c sync $SCRATCH_MNT
	_scratch_unmount
	# key for the descriptor item is <inode, BTRFS_VERITY_MERKLE_ITEM_KEY, 0>,
	# 88 is X. So we write 5 Xs to somewhere in the middle of the first
	# merkle item
	$BTRFS_CORRUPT_BLOCK_PROG -r 5 -I $ino,37,0 -v 88 -o 100 -b 5 $SCRATCH_DEV > /dev/null
	_scratch_mount
	validate $f
}

# real QA test starts here
_scratch_mkfs >/dev/null
_scratch_mount

corrupt_inline
corrupt_prealloc_to_reg
corrupt_reg_to_prealloc
corrupt_punch_hole
corrupt_plug_hole
corrupt_verity_descriptor
corrupt_root_hash
corrupt_merkle_tree

# we intentionally corrupted, re-mkfs to avoid tripping the corrupted fs error
_scratch_unmount
_scratch_mkfs >/dev/null

status=0
exit
